@using OrchardCore.Forms.ViewModels
@model FormInputElementVisibilityViewModel

@foreach (var group in Model.Groups)
{
    foreach (var rule in group.Rules)
    {
        string containerId = Guid.NewGuid().ToString("N");

        <div id="@containerId"
             class="form-group visibility-target d-none"
             data-targetInput="@rule.Field"
             data-operator="@rule.Operator"
             data-value="@rule.Value"
             data-action="@Model.Action">
        </div>
    }
}

<script>
    document.addEventListener("DOMContentLoaded", () => {

        const rulesMap = {};

        document.querySelectorAll('.visibility-target').forEach(ruleElement => {
            const targetInput = ruleElement.dataset.targetinput;

            if (!rulesMap[targetInput]) {
                rulesMap[targetInput] = [];
            }

            rulesMap[targetInput].push(ruleElement);
        });

        function initializeWidgetVisibility() {
            Object.keys(rulesMap).forEach(targetInput => {

                rulesMap[targetInput].forEach(ruleElement => {

                    const action = ruleElement.dataset.action?.toLowerCase();

                    const widget = ruleElement.closest('.widget');

                    if (widget) {
                        if (action === "hide") {
                            widget.classList.add("d-none");
                        }
                        else if (action === "show") {
                            widget.classList.remove("d-none");
                        }
                    }
                });
            });
        }

        initializeWidgetVisibility();

        Object.keys(rulesMap).forEach(targetInput => {

            if (!targetInput || targetInput.trim() === "") {
                return;
            }

            const inputFieldRule = document.getElementById(targetInput) || document.querySelector(`[name="${targetInput}"]`);
            if (!inputFieldRule) {
                return;
            }

            inputFieldRule.addEventListener("change", () => {
                passRules(targetInput, inputFieldRule, rulesMap[targetInput]);
            });
        });

        function passRules(targetInput, inputFieldRule, rules) {
            let triggerValue = "";

            if (inputFieldRule.type === "checkbox") {
                triggerValue = inputFieldRule.checked ? "true" : "false";
            }
            else if (inputFieldRule.type === "number") {
                triggerValue = parseFloat(inputFieldRule.value);
            }
            else {
                triggerValue = inputFieldRule.value?.trim().toLowerCase() || "";
            }

            let someRulePassed = false;

            rules.forEach(ruleElement => {
                const operator = ruleElement.dataset.operator?.toLowerCase();

                let ruleValueRaw = (ruleElement.dataset.value || "").trim().toLowerCase();

                let ruleValue = ruleValueRaw;

                if (inputFieldRule.type === "number") {
                    ruleValue = parseFloat(ruleValueRaw);
                }

                let rulePassed = false;

                switch (operator) {
                    case null:
                    case "":
                    return;
                    case "is":
                    rulePassed = (triggerValue === ruleValue);
                    break;
                    case "isnot":
                    rulePassed = (triggerValue !== ruleValue);
                    break;
                    case "empty":
                    rulePassed = (triggerValue === "" || isNaN(triggerValue));
                    break;
                    case "notempty":
                    rulePassed = (triggerValue !== "" && !isNaN(triggerValue));
                    break;
                    case "contains":
                    rulePassed = triggerValue.includes(ruleValue);
                    break;
                    case "doesnotcontain":
                    rulePassed = !triggerValue.includes(ruleValue);
                    break;
                    case "startswith":
                    rulePassed = triggerValue.startsWith(ruleValue);
                    break;
                    case "endswith":
                    rulePassed = triggerValue.endsWith(ruleValue);
                    break;
                    case "greaterthan":
                    rulePassed = triggerValue > ruleValue;
                    break;
                    case "lessthan":
                    rulePassed = triggerValue < ruleValue;
                    break;
                    default:
                    console.warn(`Unknown operator for "${targetInput}": ${operator}`);
                    break;
                }

                if (rulePassed) {
                    someRulePassed = true;
                }
            });

            if (rules.length > 0) {
                const widget = rules[0].closest('.widget');
                if (widget) {
                    if (someRulePassed) {
                        widget.classList.remove("d-none");
                    } else {
                        widget.classList.add("d-none");
                    }
                }
            }
        }
    });
</script>
